<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Public Data Cryptography</title>
    <link rel="stylesheet" href="style.css">
    <script type="module">
        import * as components from './scripts/components.js';
        window.BN = components.BN;
    </script>
    <script src="scripts/sha256.min.js"></script>
</head>

<body>
    
<article>
    <h1>
        Public Data Cryptography
    </h1>
    <subtitle>Cryptography that liberates data.</subtitle>
</article>


<authors>
    <author>
        <name>
            <first>Mikeal</first>
            <last>Rogers</last>
        </name>
        <handle>@mikeal</handle>
    </author>
</authors> 

<article>
    <h1>Data in the Public Interest</h1>
    <article>
        Data is said to appear "in public" when it enters our shared awareness 
        (also called the "public sphere").
    </article>
    
    <article>
        The public sees data...
    </article> 

    <article>
        The public writes data...
    </article>

    <article>
        The public moves data...
    </article>
    <article>
        While the public's participation in this data is critical to
        establishing its value, the public retains little to no rights
        to most data as it is governed by copyright law.

        Public Data Cryptography seeks to provide the means for the public
        to gain new power over data without the need to "own" or otherwise
        encode, store or transport data from where it currently resides.    
    </article>
   
</article>

<article>
    <p>Public Data Cryptography is an open-ended realm of inter-operable cryptography.</p>
    <p>The public can define processes for assembly cryptography into a sequential
        <italic>assembly</italic>. Algorithms can then be defined that arrive at
        unique cryptographic addresses and proofs for that assembly.
    </p>
    <p>Data is never "encoded" into new types or formats, algorithms that form 
        the assembly instructions for human readable definitions of types and other
        structures and relationships. Data produced in any format in any type can 
        then be used as input to these algorithms resulting in proofs that
        arrive at guaranteed unique addresses for that data <strong>regardless
        of its type or format a system preferred to encode it</strong>.
    </p>
    <p>
        These "assemblies" can be defined in public and used by anyone without
        anyone permission or approval structure of any kind. Implementations that
        arrive at compatible assemblies will arrive at compatible proofs, 
        so the open "market of ideas" is the only form of consensus.
    </p>
</article>

<article>
    <h1>Proof of Sequential Relativity</h1>
    
    <article>
        <h2>Algorithm</h2>

        <p>Proof of Sequential Relativity is a general puprose algorith that arrives
            at guaranteed to be unique address for data <italic>as it appears that sequence</italic>.
        </p>
        <p>The process of generating the address will also include useful inclusion proofs.</p>
        <p>The algorithm is "flat" in that it only works with a single sequence at a time,
            but since there is no differentiation between data types or formats, the 
            hash result can be used as input recursively, so implementations are free to
            implement the algorithm over assemblies of arbitrary depth.
        </p>

        <script id="psr-script">
const toBinary = str => new TextEncoder().encode(str);
/* psr: proof of sequential relativity */
function psr (arr, inclusions=[], hasher = sha256) {
    arr = arr.map(x => {
        if (x instanceof Uint8Array) {
            return hasher.array(x);
        }
        if (typeof x === 'string') {
            return hasher.array(toBinary(x))
        }
        if (Array.isArray(x)) {
            const result = proofOfSequentialRelativity(x, inclusions, hasher)
            inclusions.push([result.proof, result.inclusions])
            return result.proof
        }
        throw new Error('Unknown type')
    })
    if (!arr.length) throw new Error('Empty array')

    const hash = hasher.create()
    arr.forEach(x => hash.update(x))
    const proof = hash.array()
    inclusions.push[[proof, arr]]

    return { proof, inclusions }
}   
        </script>
        <code-highlighter script-id="psr-script"></code-highlighter>

    </article>

    <article>
        <h1>Authoring Public Data Algorithms</h1>
        <p>Now we can write assemblies that result in cryptographic proofs.</p>
        <p>Later, we'll see how these proofs and assemblies can be used
            to gain new power over data without the need to "own" it or
            ever even encode and store it.
        </p>
        <script id="hello-world">
hw = ['hello', 'world']
result = psr(hw)
        </script>

        <code-highlighter script-id="hello-world"></code-highlighter>

        <p>As an example, we can examine the cryptography for describing and
            entity and being typed and as being untyped.
        </p>

        <script id="typing">
const untyped = psr(new Uint8Array([7]))
const typed =   psr([ new Uint8Array([7]), 'as a Uint8Array' ])
        </script>

        <code-highlighter script-id="typing"></code-highlighter>

        <p>This gives us maximal flexibility and knowledge of what is 
            being agreed upon. If we wish to produce other agreement,
            we can do so by producing other assemblies, which means that
            specifications are irrelevant and only unique assemblies that
            entirely describe the agreement in question can be produced.
        </p>
    
     </article>

</body>
</html>
