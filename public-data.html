<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Public Data Cryptography</title>
    <link rel="stylesheet" href="style.css">
    <script type="module">
        import * as components from './scripts/components.js';
        window.BN = components.BN;
    </script>
    <script src="scripts/sha256.min.js"></script>
</head>

<body>
    
<slideshow-button></slideshow-button>

<article>
    <h1>
        Public Data Cryptography<br>
        <subtitle>Cryptography that liberates data.</subtitle>
    </h1>
</article>


<authors>
    <author>
        <name>
            <first>Mikeal</first>
            <last>Rogers</last>
        </name>
        <handle>@mikeal</handle>
    </author>
</authors> 

<article>
    <h1>Data in the Public Interest</h1>
    <card>
        <p>
            Data is said to appear "in public" when it enters our shared awareness 
            (also called the "public sphere").
        </p>
        
    </card>
    
    <card>
        <p>
            The public sees data...
        </p>
    </card> 

    <card>
        <p>
            The public writes data...
        </p>
    </card>

    <card>
        <p>The public moves data...</p>
    </card>
    <card>
        <p>The value of this data depends upon the publics participation in it.</p>
        <p>What we cannot see, we do not find of value.</p>
        <p>This cryptography seeks to provide the means for us, <strong>the public</strong>,
        to gain new data freedoms <italic>without the need to <strong>own</strong></italic> or otherwise
        encode, store or move data from where it currently resides.</p>
    </card>
    <card>
        <p>This cryptography culminates into 
        something akin to the "freedom to fork" all data visible
        to human beings.</p>
        <p>The resulting cryptography isn't "ownable" like a blockchain,
        isn't "governable" by instutions or individuals, and enforces
        no consensus between actors other than what results in compatible
        proofs as defined by those actors that wish to agree.</p>
    </card>
</article>

<article>
    <h1><code>hash()</code> and <code>seq()</code></h1>
    <card>
        <p>Public Data Cryptography avoids jargon and abstractions by describing
            cryptographic proceses using <strong><italic>only two function interfaces</italic></italive></strong>.
         </p>
        <p>These two functions are <code>hash()</code> and <code>seq()</code>.</p>
        <p>The rest of what is defined here as "Public Data Cryptography" is nothing
            but the deterministic result of these two functions applied to
            a variety of different sequences using different implementations
            of these two functions.
        </p>
    </card>
    <card>
        <h2><code>hash(<italic>input</italic>)</code></h2>
        <p>The function <code>hash()</code> is already considered to be defined
            by existant public cryptography. It already has a known interface
            in which a single <code>input</code> returns a verifiable result.
        </p>
        <p>Existant common langugae often refers to <code>hash()</code> results 
            as "hashes" but this can get rather confusing with the term for the 
            function itself. As such, we rely upon another common term for hash 
            results which is <code>proof</code>, as in "proof specific bytes in
            specific order were passed to a hash function".
         </p>
    </card>
    <card>
        <h2><code>seq(<italic>input1</italic>, <italic>input2</italic>, ...)</code></h2>
        <p>The only new term we will introduce is <code>seq()</code> which is
            identical to <code>hash()</code> except it takes <italic>multiple arguments</italic>
            and returns a unique <code>proof</code> for those individuated arguments were
            passed in that order.
         </p>
         <p>A requirement of this function is that <code>seq(one, two)</code> would
            not return the same proof as <code>seq(one + two)</code> as would be
            case with <code>hash()</code>.
        </p>
        <p>As such, <code>seq()</code> is a <italic>sequential</italic> hash function.</p>
    </card>
     
    <card>
        <p>Now we, the public, can describe <italic>sequences</italic> that are assembled 
            into proofs that are guaranteed to be unique.
        </p>
        <p>In order to arrive at compatible proofs, actors will need to use identical
            implementations of <code>seq()</code> and <code>hash()</code> (like sha2-256)
            but the public is free to define new algorithms and implementations of either
            interface.
        </p>
        <p>Different implementations of <code>seq()</code> may also produce useful
            "inclusion proofs" depending upon the algorith. Each algorithm's proof 
            inclusions will offer different powers we can explor later on, but first 
            we'll need to define a useful implementation of `seq()
        </p>
    </card>
    
</article>

<article>
    <p>Public Data Cryptography is an open-ended realm of inter-operable cryptography.</p>
    <p>The public can define processes for assembly cryptography into a sequential
        <italic>assembly</italic>. Algorithms can then be defined that arrive at
        unique cryptographic addresses and proofs for that assembly.
    </p>
    <p>Data is never "encoded" into new types or formats, algorithms that form 
        the assembly instructions for human readable definitions of types and other
        structures and relationships. Data produced in any format in any type can 
        then be used as input to these algorithms resulting in proofs that
        arrive at guaranteed unique addresses for that data <strong>regardless
        of its type or format a system preferred to encode it</strong>.
    </p>
    <p>
        These "assemblies" can be defined in public and used by anyone without
        anyone permission or approval structure of any kind. Implementations that
        arrive at compatible assemblies will arrive at compatible proofs, 
        so the open "market of ideas" is the only form of consensus.
    </p>
</article>


<article>
    <h1>Proof of Sequential Relativity</h1>
    
    <card>
        <h2>Algorithm</h2>

        <p>Proof of Sequential Relativity is a general puprose algorith that arrives
            at guaranteed to be unique address for data <italic>as it appears that sequence</italic>.
        </p>
        <p>The process of generating the address will also include useful inclusion proofs.</p>
        <p>The algorithm is "flat" in that it only works with a single sequence at a time,
            but since there is no differentiation between data types or formats, the 
            hash result can be used as input recursively, so implementations are free to
            implement the algorithm over assemblies of arbitrary depth.
        </p>

        <script id="psr-script">
const toBinary = str => new TextEncoder().encode(str);
/* psr: proof of sequential relativity */
function psr (arr, inclusions=[], hasher = sha256 /*js hash impl*/) {
    arr = arr.map(x => {
        if (x instanceof Uint8Array) {
            return hasher.array(x);
        }
        if (typeof x === 'string') {
            return hasher.array(toBinary(x))
        }
        if (Array.isArray(x)) {
            const result = psr(x, inclusions, hasher)
            inclusions.push([result.proof, result.inclusions])
            return hasher.array(result.proof)
        }
        throw new Error('Unknown type')
    })
    if (!arr.length) throw new Error('Empty array')

    const hash = hasher.create()
    arr.forEach(x => hash.update(x))
    // proof of sequence (but not described as a discreet unit)
    const proof = hash.array()
    inclusions.push[[proof, arr]]

    return { proof, inclusions }
}   
        </script>
        <code-highlighter script-id="psr-script"></code-highlighter>

    </card>

    <card>
        <h1>Authoring Public Data Algorithms</h1>
        <p>Now we can write assemblies that result in cryptographic proofs.</p>
        <p>Later, we'll see how these proofs and assemblies can be used
            to gain new power over data without the need to "own" it or
            ever even encode and store it.
        </p>
        <script id="hello-world">
hw = ['hello', 'world']
result = psr(hw)
        </script>

        <code-highlighter script-id="hello-world"></code-highlighter>

        <p>As an example, we can examine the cryptography for describing and
            entity and being typed and as being untyped.
        </p>

        <script id="typing">
const untyped = psr(new Uint8Array([7]))
const typed =   psr([ new Uint8Array([7]), 'as a Uint8Array' ])
        </script>

        <code-highlighter script-id="typing"></code-highlighter>

        <p>This gives us maximal flexibility and knowledge of what is 
            being agreed upon. If we wish to produce other agreement,
            we can do so by producing other assemblies, which means that
            specifications are irrelevant and only unique assemblies that
            entirely describe the agreement in question can be produced.
        </p>
    
    </card>
</article>
<script>
window.onload = function() {
    // Select all article elements
    let articles = document.querySelectorAll('article');
    const nav = document.createElement('navigation-footer')
    nav.classList.add('onlylfullscreen');

    // Loop over the article elements
    articles.forEach(function(article) {
        // Create an empty card element
        let titleCard = document.createElement('card');

        // Add the "onlylfullscreen" class to the empty card
        titleCard.classList.add('onlylfullscreen');

        // Insert the empty card as the first child of the article
        article.insertBefore(titleCard, article.firstChild);

        // Select the first h1 element within the current article
        let h1 = article.querySelector('h1');

        // If an h1 element was found, clone it
        if (h1) {
            let clonedH1 = h1.cloneNode(true);

            // Select all card elements within the current article
            let cards = Array.from(article.querySelectorAll('card'));

            // Loop over the card elements
            cards.forEach(function(card) {
                // Insert the cloned h1 element into the card
                if (card.firstChild) {
                    card.insertBefore(clonedH1.cloneNode(true), card.firstChild);
                } else {
                    card.appendChild(clonedH1.cloneNode(true));
                }
                card.appendChild(nav.cloneNode(true))
            });
        }
    });
};
</script>
</body>
</html>
